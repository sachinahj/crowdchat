#!/usr/bin/env node
var debug = require('debug')('twitter-crowd');
var app = require('../app');
var io = require('socket.io');


app.set('port', process.env.PORT || 3000);

var server = app.listen(app.get('port'), function() {
  debug('Express server listening on port ' + server.address().port);
});

// to rad prototype function
Number.prototype.toRad = function() {
   return this * Math.PI / 180;
}
Number.prototype.toDeg = function() {
   return this * 180 / Math.PI;
}


var clients = {};
var lone_users = [];
var available_crowds = [];
var crowd_counter = 1;


var User = function (new_user, sid) {
  this.name = new_user.name;
  this.sid = sid;
  this.location = {
    latitude: new_user.latitude,
    longitude: new_user.longitude,
    accuracy: new_user.accuracy
  };
  this.distance_from = function (user_crowd) {
    var lat1 = this.location.latitude;
    var lon1 = this.location.longitude;
    var lat2 = user_crowd.location.latitude;
    var lon2 = user_crowd.location.longitude;
    var R =  6371; // km 
    var x1 = lat2-lat1;
    var dLat = x1.toRad();  
    var x2 = lon2-lon1;
    var dLon = x2.toRad();  
    var a = Math.sin(dLat/2) * Math.sin(dLat/2) + 
            Math.cos(lat1.toRad()) * Math.cos(lat2.toRad()) * 
            Math.sin(dLon/2) * Math.sin(dLon/2);  
    var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); 
    var d = R * c; 
    return d;
  }
};

var Crowd = function (location, users) {
  this.id = crowd_counter;
  crowd_counter += 1;
  this.location = location;
  this.users = users;
  this.messages = [];
  this.addUser = function (new_user) {
    this.users.push(new_user);
    return this;
  }

};


var sio = io.listen(server);
sio.sockets.on('connection', function (socket) {
  console.log('a socket connected: ' + socket.id);
  clients[socket.id] = socket;

  socket.on('newUser', function (new_user) {
    new_user = new User(new_user, socket.id);
    socket.emit('userCreated', new_user);
    
    var crowd = getCrowd(new_user);
    if (crowd) {
      for (var i = 0; i < crowd.users.length; i++) {
        clients[crowd.users[i].sid].join(crowd.id);
      }
      socket.emit('crowdAvailable', crowd);
      sio.sockets.to(crowd.id).emit('crowdUpdate', crowd);
    } else {
      socket.emit('crowdAvailable', false);
    }
  });
  
  



















  socket.on('disconnect', function () {
    console.log("a socket disconnected");
  });

});



function getCrowd (new_user) {

  for (var i = 0; i < available_crowds.length; i++) {
    if (new_user.distance_from(available_crowds[i]) < 1) {
      var crowd = available_crowds[i].addUser(new_user);
      return crowd;
    }
  }

  for (var i = 0; i < lone_users.length; i++) {
    if (new_user.distance_from(lone_users[i]) < 1) {
      var found_user = lone_users.splice(i,1)[0];
      var midpoint_location = DetermineMidPoint(found_user.location, new_user.location)
      var new_crowd = new Crowd(midpoint_location, [found_user, new_user]);
      available_crowds.push(new_crowd)
      return new_crowd;
    }
  }
  
  lone_users.push(new_user);
  return false;
    
}


function DetermineMidPoint (location1, location2) {
  var lat1 = location1.latitude;
  var lon1 = location1.longitude;
  var lat2 = location2.latitude;
  var lon2 = location2.longitude;
  
  var x2 = lon2-lon1;
  var dLon = x2.toRad();

  lat1 = lat1.toRad();
  lat2 = lat2.toRad();
  lon1 = lon1.toRad();
  lon2 = lon2.toRad();

  var Bx = Math.cos(lat2) * Math.cos(dLon);
  var By = Math.cos(lat2) * Math.sin(dLon);
  var lat3 = Math.atan2(Math.sin(lat1) + Math.sin(lat2), Math.sqrt((Math.cos(lat1) + Bx) * (Math.cos(lat1) + Bx) + By * By));
  var lon3 = lon1 + Math.atan2(By, Math.cos(lat1) + Bx);

  return {
    latitude: lat3.toDeg(),
    longitude: lon3.toDeg()
  }
}
