#!/usr/bin/env node
var debug = require('debug')('twitter-crowd');
var app = require('../app');
var io = require('socket.io');


app.set('port', process.env.PORT || 3000);

var server = app.listen(app.get('port'), function() {
  debug('Express server listening on port ' + server.address().port);
});

// to rad prototype function
Number.prototype.toRad = function() {
   return this * Math.PI / 180;
}
Number.prototype.toDeg = function() {
   return this * 180 / Math.PI;
}


var clients = {};
var lone_users = [];
var available_crowds = [];
var crowds_counter = 1;
var users_counter = 1;


var User = function (new_user, sid) {
  this.id = users_counter;
  users_counter += 1;
  this.name = new_user.name;
  this.sid = sid;
  this.location = {
    latitude: new_user.latitude,
    longitude: new_user.longitude,
    accuracy: new_user.accuracy
  };
  this.distance_from = function (user_crowd) {
    var lat1 = this.location.latitude;
    var lon1 = this.location.longitude;
    var lat2 = user_crowd.location.latitude;
    var lon2 = user_crowd.location.longitude;
    var R =  6371; // km 
    var x1 = lat2-lat1;
    var dLat = x1.toRad();  
    var x2 = lon2-lon1;
    var dLon = x2.toRad();  
    var a = Math.sin(dLat/2) * Math.sin(dLat/2) + 
            Math.cos(lat1.toRad()) * Math.cos(lat2.toRad()) * 
            Math.sin(dLon/2) * Math.sin(dLon/2);  
    var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); 
    var d = R * c; 
    return d;
  }
};

var Crowd = function (location, users) {
  this.id = crowds_counter;
  crowds_counter += 1;
  this.location = location;
  this.users = users;
  var message_counter = 0;
  this.messages = [];
  this.addUser = function (new_user) {
    this.users.push(new_user);
    return this;
  }
  this.addMessage = function (user_id, name, content) {
    var message = {
      id: message_counter,
      user_id: user_id,
      name: name,
      content: content
    }
    message_counter += 1
    this.messages.push(message);
    return message;
  }
};



var sio = io.listen(server);
sio.sockets.on('connection', function (socket) {
  console.log('a socket connected: ' + socket.id);
  clients[socket.id] = socket;

  socket.on('newUser', function (new_user) {
    new_user = new User(new_user, socket.id);
    socket.emit('userCreated', new_user);
    
    var selected_crowd = getCrowd(new_user);
    var crowd = selected_crowd[0];
    var crowd_type = selected_crowd[1];

    if (crowd_type === "new") {

      socket.emit('crowdAvailable', crowd);
      sio.sockets.to(crowd.id).emit('crowdUpdate', crowd);

    } else if (crowd_type === "update") {

      clients[new_user.sid].join(crowd.id);
      socket.emit('crowdAvailable', crowd);
      sio.sockets.to(crowd.id).emit('crowdUpdate', crowd);

    } else {

      socket.emit('crowdAvailable', undefined); 
    }
  });


  socket.on('createNewMessage', function (new_message) {
    var crowd_id = new_message.crowd_id;
    var message_crowd = createMessageForCrowd(new_message, crowd_id);

    sio.sockets.to(crowd_id).emit('crowdUpdate', message_crowd[1]);
    sio.sockets.to(crowd_id).emit('newMessage', message_crowd[0]);
  });

















  socket.on('disconnect', function () {
    console.log("a socket disconnected");
  });

});

function createMessageForCrowd (new_message, crowd_id) {

  for (var i = 0; i < available_crowds.length; i++) {
    if (available_crowds[i].id === crowd_id) {
      var message = available_crowds[i].addMessage(new_message.user_id, new_message.name, new_message.content);
      var crowd = available_crowds[i];
      console.log("crowd", crowd);
      return [message, crowd];
    }
  }  

  return false;

}

function getCrowd (new_user) {

  for (var i = 0; i < available_crowds.length; i++) {
    if (new_user.distance_from(available_crowds[i]) < 1) {
      var crowd = available_crowds[i].addUser(new_user);
      return [crowd, "update"];
    }
  }

  for (var i = 0; i < lone_users.length; i++) {
    if (new_user.distance_from(lone_users[i]) < 1) {
      var found_user = lone_users.splice(i,1)[0];
      var midpoint_location = DetermineMidPoint(found_user.location, new_user.location)
      var new_crowd = new Crowd(midpoint_location, [found_user, new_user]);
      for (var i = 0; i < new_crowd.users.length; i++) {
        clients[new_crowd.users[i].sid].join(new_crowd.id);
      }
      available_crowds.push(new_crowd)
      return [new_crowd, "new"];
    }
  }
  
  lone_users.push(new_user);
  return [null, "none"];
    
}


function DetermineMidPoint (location1, location2) {
  var lat1 = location1.latitude;
  var lon1 = location1.longitude;
  var lat2 = location2.latitude;
  var lon2 = location2.longitude;
  
  var x2 = lon2-lon1;
  var dLon = x2.toRad();

  lat1 = lat1.toRad();
  lat2 = lat2.toRad();
  lon1 = lon1.toRad();
  lon2 = lon2.toRad();

  var Bx = Math.cos(lat2) * Math.cos(dLon);
  var By = Math.cos(lat2) * Math.sin(dLon);
  var lat3 = Math.atan2(Math.sin(lat1) + Math.sin(lat2), Math.sqrt((Math.cos(lat1) + Bx) * (Math.cos(lat1) + Bx) + By * By));
  var lon3 = lon1 + Math.atan2(By, Math.cos(lat1) + Bx);

  return {
    latitude: lat3.toDeg(),
    longitude: lon3.toDeg()
  }
}
